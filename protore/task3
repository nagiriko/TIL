■ 実装するファイル名
・regexp3.rb（「Regexp」フォルダ内に作成すること）

■ メソッドの概要
・配列（要素は文字列）を引数で受け取り、1つ1つに対して正規表現を適用する
・正規表現に一致した要素のみが格納された、「新たな配列」を作成する
・「新たな配列」に格納された要素を、メソッドの実行結果として出力する


■ 正規表現の条件
・0120から始まる電話番号（フリーダイヤル）のみと一致する
・「0120」に続く部分は、3桁3桁のみを許容する
・「0120-xxx-xxx」または「0120(xxx)xxx」の記述のみを許容する


★回答★
def extract_free_dial(numbers)
  free_dials = []
  i = 0
  numbers.each do |number|
    if number.match(/\A0120[-(]\d{3}[-)]\d{3}\z/)!= nil
      free_dials << numbers[i]
    end
    i += 1
  end
  return free_dials
end

phone_numbers = ["0120-111-111", "080-1111-1111", "0120(111)111", "0120444444"]

puts extract_free_dial(phone_numbers)



★解説★
まず、2行目で、正規表現に一致した要素のみを格納する「新たな配列」として、free_dialsという空の配列を用意しました。

次に、4〜9行目では、電話番号を1つ1つチェックするために、eachメソッドを使用して配列から電話番号の要素を取り出しています。この時、取り出した要素1つずつをnumberという変数名で扱うように設定しています。

5〜7行目では、正規表現と条件分岐を使用して、変数numberが正規表現の条件に当てはまるかを判定しています。
正規表現の条件に当てはまる変数numberは、配列 << 追加する要素の記述で、free_dialsという配列に要素として加えています。
この追加の際に「どの要素番号の要素を追加するか」を指定する必要があるので、変数iを事前に定義しておき、変数numberの要素番号と常に連動するようにしておきます。

正規表現としては、まず、\A0120\d{3}\d{3}\zという記述で「0120から始まり、その後ろは3桁3桁で終わる数字にマッチ」という意味の正規表現を作ります。
次に、今回は「『0120-xxx-xxx』または『0120(xxx)xxx』のみ許容」ということなので、1つめの3桁の前後を[-(]と[-)]で挟み、「1つ目の3桁の直前は-または(、1つ目の3桁の直後は-または)なものにマッチ」という意味を加えます。

最後に、メソッドの実行結果としては「抽出されたフリーダイヤル のみ」つまり「新たな配列（free_dials）の値」を出力したいので、returnメソッドを使用して、メソッドの戻り値に配列free_dialsを設定しています。
